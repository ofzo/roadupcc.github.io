<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Ignition设计文档Created: Sep 6, 2020 12:40 PM Authors: rmcilroy@, oth@ Last Updated: 2016&#x2F;03&#x2F;22 translator: @Allen roadup Background 背景The machine code generated by V8’s full-codegen compiler is verbose,">
<meta property="og:type" content="website">
<meta property="og:title" content="Ignition 设计文档">
<meta property="og:url" content="http://example.com/v8/Ignition.html">
<meta property="og:site_name" content="时光荏苒">
<meta property="og:description" content="Ignition设计文档Created: Sep 6, 2020 12:40 PM Authors: rmcilroy@, oth@ Last Updated: 2016&#x2F;03&#x2F;22 translator: @Allen roadup Background 背景The machine code generated by V8’s full-codegen compiler is verbose,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled.png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%201.png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Ignition_(2).png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%202.png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%203.png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%204.png">
<meta property="og:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%205.png">
<meta property="article:published_time" content="2020-09-06T12:49:42.000Z">
<meta property="article:modified_time" content="2020-09-09T13:01:21.408Z">
<meta property="article:author" content="roadup">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/v8/Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled.png">


<link rel="canonical" href="http://example.com/v8/Ignition">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ignition 设计文档 | 时光荏苒
</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">时光荏苒</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3"><span class="nav-number">1.</span> <span class="nav-text">Ignition设计文档</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Background-%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">Background 背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Overall-Design-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text">Overall Design 总体设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Generation-of-Bytecode-Handlers-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">4.</span> <span class="nav-text">Generation of Bytecode Handlers 字节码处理器的产生</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bytecode-Generation-%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">Bytecode Generation 生成字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Interpreter-Register-allocation-%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D"><span class="nav-number">5.1.</span> <span class="nav-text">Interpreter Register allocation 解释器寄存器分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-chains-%E4%B8%8A%E4%B8%8B%E6%96%87%E9%93%BE"><span class="nav-number">5.2.</span> <span class="nav-text">Context chains 上下文链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constant-Pool-Entries-%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%B0%E5%BD%95"><span class="nav-number">5.3.</span> <span class="nav-text">Constant Pool Entries 常量池记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Local-Control-Flow-%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">5.4.</span> <span class="nav-text">Local Control Flow 局部控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception-Handling-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">Exception Handling 异常处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Interpreter-Code-Execution-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">Interpreter Code Execution 解释器执行代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-frame-layout-and-reserved-machine-registers-%E5%A0%86%E6%A0%88%E5%B8%83%E5%B1%80%E5%92%8C%E9%A2%84%E7%95%99%E6%9C%BA%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">Stack frame layout and reserved machine registers 堆栈布局和预留机器寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interpreter-Register-Access-%E8%AE%BF%E9%97%AE%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">6.2.</span> <span class="nav-text">Interpreter Register Access 访问解释器寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wide-operands-%E5%AE%BD%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">Wide operands 宽字符操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-Calls-JS%E8%B0%83%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">JS Calls JS调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Property-loads-stores-%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD-%E4%BF%9D%E5%AD%98"><span class="nav-number">6.5.</span> <span class="nav-text">Property loads &#x2F; stores 属性加载&#x2F;保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-ops"><span class="nav-number">6.6.</span> <span class="nav-text">Binary ops</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TurboFan-Bytecode-Graph-Builder-TurboFan%E5%AD%97%E8%8A%82%E7%A0%81%E5%9B%BE%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">TurboFan Bytecode Graph Builder TurboFan字节码图构建器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Deoptimization-%E5%8E%BB%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.</span> <span class="nav-text">Deoptimization 去优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Debugging-support-%E6%94%AF%E6%8C%81%E8%B0%83%E8%AF%95"><span class="nav-number">8.</span> <span class="nav-text">Debugging support 支持调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Source-Positions-%E6%BA%90%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.1.</span> <span class="nav-text">Source Positions 源码位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Profiler-Support-%E6%8E%A2%E6%9F%A5%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-number">8.2.</span> <span class="nav-text">Profiler Support 探查器支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future-work-%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C"><span class="nav-number">9.</span> <span class="nav-text">Future work 后续工作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Appendix-A-Table-of-Bytecodes"><span class="nav-number">10.</span> <span class="nav-text">Appendix A: Table of Bytecodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Appendix-B-Reading-Material"><span class="nav-number">11.</span> <span class="nav-text">Appendix B: Reading Material</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">博主</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner page posts-expand">
      

      

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Ignition 设计文档
</h1>

<div class="post-meta-container">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="Ignition设计文档"><a href="#Ignition设计文档" class="headerlink" title="Ignition设计文档"></a>Ignition设计文档</h1><p>Created: Sep 6, 2020 12:40 PM</p>
<p>Authors: rmcilroy@, oth@</p>
<p>Last Updated: 2016/03/22</p>
<p>translator: @Allen roadup</p>
<h1 id="Background-背景"><a href="#Background-背景" class="headerlink" title="Background 背景"></a>Background 背景</h1><p>The machine code generated by V8’s full-codegen compiler is verbose, and as such, can contribute significantly to the amount of memory used by V8’s heap for typical web-pages (a <a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1zYq6GDjSIue9JNEC9y3py8cRIcgY_vJi-j40brA7Q00/edit">previous analysis</a> showed that the code-space contributed to around 15-20% of the JS heap).</p>
<p>V8的 full-codegen 编译器生成的机器码太啰嗦，因此对于经典页面的堆内存使用量会大大增加（先前的分析显示代码空间大约占用15～20%的JS堆空间）</p>
<p>As well as causing memory pressure, this means that V8 tries very hard to avoid generating code that it thinks might not be executed. It implements <em>lazy</em> parsing and compiling, where functions are typically only compiled on first-run. This has a significant cost during webpage startup since the function’s source needs to be reparsed during the lazy compilation (e.g., <a target="_blank" rel="noopener" href="http://crbug.com/593477">crbug.com/593477</a>).</p>
<p>除了造成内存浪费， 这还意味着V8尝试尽力避免生成它认为不会执行的代码。它实现懒解析和编译，函数通常只在首次执行时编译。这在页面启动有着大量的开销，因为延迟编译需要函数源码重解析。（例如： <a target="_blank" rel="noopener" href="http://crbug.com/593477">crbug.com/593477</a>）</p>
<p>The aim of the Ignition project is to build an interpreter for V8 which executes a low-level bytecode, thus enabling run-once or non-hot code to be stored more compactly in bytecode form. Since the bytecode is smaller, compilation time is much reduced, and we will also be able to be more eager about initial compilation, which significantly improve startup time. An added advantage is that the bytecode can be fed into a Turbofan graph generator directly, thereby avoiding the need to reparse the JavaScript source code when optimizing a function in TurboFan.</p>
<p>Ignition 项目的目标是去构建一个V8的解释器，它执行低级字节码， 因此能使一次运行或者非热代码以字节码的形式更紧凑的保存。由于字节码更小， 编译时间更少，我们也能更渴望初始化编译，大大改善启动时间。 另一个优点是字节码能直接传输给Turbofan图生成器，从而避免TurboFan在优化函数时需要重新解析源码。</p>
<p>The goals of the Ignition project are:</p>
<p>Ignition项目的目标</p>
<ul>
<li><p>Reduce the size of the code-space to around 50% of its current size.</p>
<p>  减少代码空间约50%</p>
</li>
<li><p>Have reasonable performance compared to full-codegen (somewhere in the range of 2x slower on peak performance benchmarks such as Octane, significantly less slowdown on real world websites).</p>
<p>  对比full-codegen有合理的性能（在峰值性能基准中要慢约2倍例如Octane，在真实世界的网页中要慢的多）</p>
</li>
<li><p>Note: the slowdown overall will be significantly less, hopefully negligible, due to hot code being optimized by either Crankshaft or TurboFan.</p>
<p>  注意：由于Crankshaft和TurboFan对热代码的优化，总体的下降将大大减少，希望可以忽略不计。</p>
</li>
<li><p>Full support for DevTools debugging and cpu profiling.</p>
<p>  全面支持DevTools调试和cpu分析</p>
</li>
<li><p>Replace full-codegen for first-level compilation.</p>
<p>  替换full-codegen的第一层编译</p>
</li>
<li><p>We can’t replace full-codegen completely until Crankshaft is deprecated, since Crankshaft can’t deoptimize to Ignition, it instead needs to deopt to full-codegen code.</p>
<p>  在Crankshaft被删除之前，我们不能完全替换full-codegen，由于Crankshaft不能去优化到Ignition，因此它需要依赖full-codegen</p>
</li>
<li><p>A new frontend to the Turbofan’s compiler to enable optimized re-compilation without re-parsing the JS source code.</p>
<p>  一个新的Turbofan编译器的前端，能在不重解析JS源码的情况下优化重编译</p>
</li>
<li><p>Support for deoptimizing from TurboFan to the interpreter.</p>
<p>  支持从TurboFan去优化到解释器</p>
</li>
</ul>
<p>Explicit non-goals of the project (at least at this stage) are:</p>
<p>这个项目中清楚的非目标（至少在当前阶段）：</p>
<ul>
<li><p>Support for platforms not allowed to JIT code (e.g., iOS)</p>
<p>  支持不允许JIT代码的平台(如： iOS)</p>
</li>
<li><p>JIT code generation is still required for ICs and code stubs.</p>
<p>  ICs和代码剩余部分仍然需要JIT代码生成</p>
</li>
<li><p>Support non-JavaScript code executed by V8 (e.g., WASM).</p>
<p>  支持非JavaScript代码的执行，如 wasm</p>
</li>
<li><p>Equivalent performance to full-codegen compiler.</p>
<p>  和full-codegen编译器等效性能</p>
</li>
<li><p>Completely replacing the full-codegen compiler.</p>
<p>  完成替换full-codegen编译器</p>
</li>
<li><p>As outlined above, we need full-codegen both as a deoptimization target for Crankshaft, and to build some type feedback required by Crankshaft which Ignition cannot provide. As such, full-codegen will become a middle tier for hot code which will eventually be optimized by Crankshaft (any functions which the parser decides should be optimized by TurboFan will not be compiled via full-codegen though, instead they will be optimized directly by TurboFan.</p>
<p>  如上所述， 我们需要full-codegen作为Crankshaft去优化的目标， 也需要去构建一些Ignition不能提供的Crankshaft的类型反馈。因此，full-codegen将成为一个热代码的中间层，它最终将被Crankshaft优化（解析器决定应该被TurboFan优化的函数将不会被full-codegen编译，而是直接有TurboFan优化）</p>
</li>
</ul>
<h1 id="Overall-Design-总体设计"><a href="#Overall-Design-总体设计" class="headerlink" title="Overall Design 总体设计"></a>Overall Design 总体设计</h1><p>This section outlines the overall design of the Ignition bytecode interpreter, with following sections giving more details on the specifics.</p>
<p>这一节概述了Ignition字节码解释器的总体设计，下面几节提供了更多的细节信息</p>
<p>The interpreter itself consists of a set of bytecode handler code snippets, each of which handles a specific bytecode and dispatches to the handler for the next bytecode. These <a href="about:blank#_o9nf15xrscoy">bytecode handlers</a> are written in a high level, machine architecture agnostic form of assembly code, as implemented by the CodeStubAssembler class and compiled by Turbofan.</p>
<p>解释器自身由一个字节码处理器代码片段的集合组成， 每一个处理器处理一个特定的字节码，然后派发给下一个字节码。这些字节码处理器用高级的，与机器架构无关的的汇编代码编写，被CodeStubAssembler类实现并由TurboFan编译。</p>
<p>As such, the interpreter can be written once and uses TurboFan to generate machine instructions for each of the architectures supported by V8. When the interpreter is enabled, each V8 isolate contains a global interpreter dispatch table, holding a code object pointer to each bytecode handler, indexed by the bytecode value. These bytecode handlers can be included in the startup snapshot and deserialized when a new isolate is created.</p>
<p>因此，解释器能被写一次，使用TurboFan去为每一个支持V8的架构生成机器指令。当解释器开启时，每一个V8的实例包含一个全局的解释器表，包含一个指向每一个字节码处理器的对象指针，通过字节码的值索引。这些字节码处理器也能包含在启动快照中，并在新的实例创建时时反序列化。</p>
<p>In order to be run by the interpreter, a function is translated to bytecode by a <a href="about:blank#_3g7hxcfckuvm">BytecodeGenerator</a> during its initial unoptimized compile step. The <a href="about:blank#_3g7hxcfckuvm">BytecodeGenerator</a> is an AstVisitor which walks the function’s AST emitting appropriate bytecodes for each AST node. This bytecode is associated with the function as a field on the SharedFunctionInfo object, and the function’s code entry address is be set to the InterpreterEntryTrampoline builtin stub.</p>
<p>为了让解释器去运行，函数在初始编译步骤被<a href="about:blank#_3g7hxcfckuvm">BytecodeGenerator</a>转换成字节码。<a href="about:blank#_3g7hxcfckuvm">BytecodeGenerator</a>是一个AstVisitor, 它遍历函数的AST为每一个AST节点发送合适的字节码。这个字节码被函数作为一个SharedFunctionInfo对象上的字段关联， 并且这个函数代码的入口地址被设置到内建InterpreterEntryTrampoline的末尾。</p>
<p>When the function is called at runtime, the InterpreterEntryTrampoline stub is entered. This stub set up an appropriate stack frame, and then dispatch to the interpreter’s bytecode handler for the function’s first bytecode in order to <a href="about:blank#interpreter-code-execution">start execution of the function in the interpreter</a>. The end of each bytecode handler directly dispatches to the next handler via an index into the global interpreter table, based on the bytecode.</p>
<p>当函数在运行时被调用时， 从InterpreterEntryTrampoline的末尾输入。它尾部设置了合适的栈帧， 然后派发函数的第一个字节码给解释器的字节码处理器来开始执行这个函数。每一个字节码处理器的末尾通过在全局表中基于字节码的索引直接派发下一个处理器。</p>
<p>The Ignition interpreter is a register-based interpreter. These registers are not traditional machine registers, but are instead specific slots in a <em>register file</em> which is allocated as part of a function’s stack frame. Bytecodes can specify the input and output registers on which they operate through bytecode arguments, which immediately follow the bytecode itself in the BytecodeArray stream.</p>
<p>Ignition解释器时一个基于寄存器的解释器。这些寄存器不是传统的机器寄存器， 而是寄存器文件中的插槽，这些文件作为被分配给函数堆栈的一部分。字节码能通过紧随字节码的BytecodeArray流参数操作具体的输入和输出寄存器。</p>
<p>In order to reduce the size of the bytecode stream, Ignition has an accumulator register, which is used by many bytecodes as implicit input and output register. This register is not part of the <em>register file</em> on the stack, but is instead maintained in a machine register by Ignition. This minimize loading and storing repeatedly to memory for register operations. It also reduces the size of bytecode by avoiding the need to specify an input and output register for many operations. E.g., binary op bytecodes only require a single operand to specify one of the inputs, with the other input and the output registers being implicitly the accumulator register, rather than having to explicitly specify all three registers.</p>
<p>为了减少字节码流的参数， Ignition有一个累加寄存器， 它被许多字节码用作隐式的输入和输出寄存器。 这个寄存器不是堆栈上寄存器文件的一部分，而是通过Ignition在机器寄存器中维护。他可以最小化加载和存储重复的寄存器对内存的操作。它通过避免为许多操作制定输入和输出寄存器来减少字节码的尺寸。例如：二元操作字节码仅仅需要一个单一的操作去指定输入中的一个，其他的输入和输出寄存器是隐式累加寄存器，而不必显式的指明所有三个寄存器。</p>
<h1 id="Generation-of-Bytecode-Handlers-字节码处理器的产生"><a href="#Generation-of-Bytecode-Handlers-字节码处理器的产生" class="headerlink" title="Generation of Bytecode Handlers 字节码处理器的产生"></a>Generation of Bytecode Handlers 字节码处理器的产生</h1><p>Bytecode handlers are generated by the TurboFan compiler. Each handler is its own code object and is generated independently. The handlers are written as a graph of Turbofan operations, via an InterpreterAssembler, which is a subclass of the CodeStubAssembler, with some extra high-level primitives required by the interpreter (e.g., Dispatch, GetBytecodeOperand, etc.). An example of the generator function for the Ldar (LoaD Accumulator from Register) bytecode handler is as follows:</p>
<p>字节码处理器被TurboFan编译器生成。每一个处理器都有它自己的代码对象并且是独立生成的。这些处理器通过InterpreterAssembler编写为TurboFan的操作图，InterpreterAssembler是CodeStubAssembler的子类带有解释器所需要的一些额外的高层原语，例如： Dispatch， GetBytecodeOperand等。下面是一个为Ladr(Load Accumulator from Register)字节码处理器生成函数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interpreter::DoLdar</span><span class="params">(InterpreterAssembler* assembler)</span> </span>&#123;</span><br><span class="line">   Node* reg_index = __ BytecodeOperandReg(<span class="number">0</span>);</span><br><span class="line">   Node* value = __ LoadRegister(reg_index);</span><br><span class="line">   <span class="function">__ <span class="title">SetAccumulator</span><span class="params">(value)</span></span>;</span><br><span class="line">   <span class="function">__ <span class="title">Dispatch</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>The bytecode handlers are not intended to be called directly, instead each bytecode handler dispatches to the next bytecode. Bytecode dispatch is implemented as a tail call operation in TurboFan. The interpreter loads the next bytecode, indexes into the dispatch table to get the code object of the target bytecode handler, and then tail calls the code object to dispatch to the next bytecode handler.</p>
<p>字节码处理器不被直接调用，而是每一个字节码处理器派发下一个字节码。字节码分派被实现为TurboFan的尾调用操作。这个解释器加载下一个字节码，通过派发表索引获取目标字节码处理器的代码对象， 然后尾调用这个代码对象调度下一个字节码操作。</p>
<p>The interpreter also needs to maintain state across bytecode handlers in fixed machine registers. For example, a pointer to the BytecodeArray, the current bytecode offset and the value of the interpreter’s accumulator. These values are treated as parameters by TurboFan, which are received as input from the previous bytecode dispatch, and passed to the next bytecode handler as parameters to the bytecode dispatch tail call. The bytecode handler dispatch calling convention specifies fixed machine registers for these parameters, which enables them to be threaded through interpreter dispatches without needing to be pushed / popped onto the stack.</p>
<p>解释器也需要在固定机器寄存器中垮字节码处理器时维护状态。 例如一个指向BytecodeArray的指针，当前的字节码的偏移量和解释器的累加器的值。这些值由TurboFan作为参数，它从前一个字节码分派出接受参数，然后传递给下一个字节码处理器作为这个字节码的尾调用。字节码处理器通常为这些参数指定固定的及其寄存器并分派调用， 这允许它们通过解释器分派线程化而不需要在栈上push/pop。</p>
<p>Once the graph for a bytecode handler is produced it is passed through a simplified version of Turbofan’s pipeline and assigned to the corresponding entry in the interpreter table.</p>
<p>字节码处理器图生成后， 将被传递给一个TurboFan链路的简化版本， 并且分配到解释器表的相应入口。</p>
<h1 id="Bytecode-Generation-生成字节码"><a href="#Bytecode-Generation-生成字节码" class="headerlink" title="Bytecode Generation 生成字节码"></a>Bytecode Generation 生成字节码</h1><p>To compile a function to bytecode, the JavaScript code is parsed to generate its AST (Abstract Syntax Tree). The BytecodeGenerator walks this AST and generates bytecode for each of the AST nodes as appropriate.</p>
<p>为了编译函数到字节码， js代码将被解析生成AST。BytecodeGenerator遍历AST然后为每一个AST节点生成合适的字节码</p>
<p>For example, the snippet of Javascript “arr[1]” will be translated into the following AST tree:</p>
<p>例如， js片段 “ arr[1] ” 将被转换为下面的AST树</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled.png"></p>
<p>The BytecodeGenerator will walk this tree, first visiting the KeyedPropertyLoad node, which will first visit the <em>Object</em> edge to generate code which evaluates the object on which the keyed load should be performed. In this case, the object is a local variable, which is already assigned to an interpreter register (e.g., r3), so code is generated to load this register into the accumulator (Ldar r3) and control returns to KeyedPropertyLoad node visitor. This visitor allocates a temporary register (e.g., r6) to save the object in, and generates code to store the accumulator into this register (Star r6)<a href="about:blank#fn1">1</a>. The <em>Key</em> edge is now visited to generate code to produce the key for the property load. In this case this node is an integer literal 1, and so a LdaSmi #1 bytecode is output to load 1 into the accumulator. Finally the code to perform the keyed property load is output, resulting in a snippet of bytecode:</p>
<p>BytecodeGenerator将遍历这棵树， 首先访问KeyedPropertyLoad节点， 它将首先访问<em>Object</em>边(左子节点)生成代码，代码评估应该加载哪个键控属性。 在这种情况下，这个对象是一个局部变量， 它已经被分配到解释器的寄存器（例如， r3）， 因此代码被生成到加载这个寄存器到累加器（Ldar r3），并且控制权返回到KeyedPropertyLoad节点。这个访问器分配一个临时的寄存器（如 r6）保存这个对象， 然后生成代码来保存累加器到寄存器（Star r6）。<em>Key</em>边(右子节点)现在访问到生成的代码提供一个加载属性的key。在这种情况下这个节点是一个整数字面量1， 因此输出一个 LdaSmi #1 字节码去加载 1 到累加器中。最终输出一个键控属性加载代码， 结果是一个字节码片段：</p>
<p><em>Note: Since the object was already in a register, this move in and out of the accumulator is redundant, therefore we have register aliasing optimizations which avoid it, described in more detail in Section TODO.</em></p>
<p>由于对象已经存在于寄存器中，这中进出寄存器的操作是多余的， 因此我们有寄存器别名优化来避免它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ldar r3</span><br><span class="line">Star r6</span><br><span class="line">LdaSmi #1</span><br><span class="line">KeyedLoadIC r6 &lt;feedback slot&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>PS : <em>翻译时生成的字节码已发生变化(2020-09-06)</em></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LdaGlobal [0], [0]</span><br><span class="line">Star r1</span><br><span class="line">LdaSmi [1]</span><br><span class="line">LdaKeyedProperty r1, [2]</span><br><span class="line">Star r0</span><br><span class="line">Return</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>The BytecodeGenerator uses a BytecodeArrayBuilder to generate well formed array of bytecodes for the interpreter. The BytecodeArrayBuilder provides flexibility in what raw bytecodes are emitted. For example, we can have multiple bytecodes which perform the same semantic operation, but with some having wider (e.g., 16 bit or 32 bit) operands. The BytecodeGenerator doesn’t need to know any of this, instead it simply asks the BytecodeArrayBuilder to output a given bytecode with a set of operands, and the BytecodeArrayBuilder chooses the appropriate width for the operands.</p>
<p>BytecodeGenerator使用一个BytecodeArrayBuilder为解释器生成格式良好的字节码数组。BytecodeArrayBuilder在原始字节码被发送时提供灵活性。例如， 我们有多个字节码执行相同的语义操作， 但有些具有更宽的操作数（例如 16位或者32位）。BytecodeGenerator不需要知道这些，只是要求BytecodeArrayBuilder输出一个一组带有操作数的集合， 然后BytecodeArrayBuilder选择合适的操作数宽度。</p>
<p>Once the bytecode is generated it is stored on a field in the SharedFunctionInfo. As well as being used by the interpreter for code execution, this bytecode is representative enough to enable generation of the <a href="about:blank#turbofan-bytecode-graph-builder">TurboFan’s compiler’s graph</a> without having to regenerate the function’s AST. This avoids the current requirement to reparse the function’s JavaScript source before recompile.</p>
<p>生成的字节码存储在SharedFunctionInfo的一个字段上。该字节码不仅可以被解释器执行，而且具有足够的代表性能生成TurboFan的编译图，而不必重新生成函数AST。这可以避免当前在重新编译前需要重新解析函数源码的需求。</p>
<h2 id="Interpreter-Register-allocation-解释器寄存器分配"><a href="#Interpreter-Register-allocation-解释器寄存器分配" class="headerlink" title="Interpreter Register allocation 解释器寄存器分配"></a>Interpreter Register allocation 解释器寄存器分配</h2><p>During bytecode generation, the BytecodeGenerator allocates registers in a function’s register file for local variables, <a href="about:blank#context-chains">context object pointers</a> (used to maintain state across function closures), and temporary values required for expression evaluation (the expression stack). During execution, space for the register file is allocated during the function’s prologue as part of the function’s stack frame. Bytecodes operate on these registers by specifying a specific register index as an bytecode operand, which the interpreter uses to load from or store to the specific stack slot associated with this register.</p>
<p>在字节码生成期间，BytecodeGenerator在寄存器文件为局部变量，上下文对象指针（用来维护闭包函数的状态），和执行表达式需要的临时值（表达式堆栈）分配寄存器。在执行期间， 寄存器文件空间在函数的开始作为函数栈帧的一部分被分配。 字节码在这些寄存器上依靠指定寄存器索引作为一个操作数进行操作， 解释器用来从与此关联的特定堆栈中加载或存储。</p>
<p>Since the register indexes map directly to the function stack frame slots, the interpreter can also directly access other slots on the stack as registers. For example, the function context and function closure pointers which are pushed onto the stack by the prologue can be accessed directly as Register::current_context() and Register::function_context() by any bytecode which has register operands. Similarly, the arguments passed to the function (including the implicit <this> parameter) can also be accessed by register.</p>
<p>由于寄存器索引直接映射到函数的堆栈空间， 解释器也能作为寄存器直接访问栈上的其他空间。例如， 在开场被pusdao 堆栈的函数上下文和函数闭包指针能被任何有寄存器操作的字节码当作Register::current_context()和Register::function_context() 直接访问。类似的，参数被传递给函数（包括隐式的this参数）也能被寄存器访问。</p>
<p>The figure below shows an example stack frame for a function and the mapping of registers indexes and their raw operand values, to stack slots:</p>
<p>下图显示一个一个函数、寄存器索引映射和他们原始操作值在栈上的示例</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%201.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%201.png"></p>
<pre><code>                          原始寄存器操作值（相反的顺序，由于栈在内存中向下增长）</code></pre>
<p>Due to this register file approach, Ignition doesn’t dynamically push and pop values onto the stack during expression evaluation as full-codegen does (the only exception is pushing arguments for calls, however this is done in a separate builtin, not in the interpreter itself). This has the advantage the the stack frame can be allocated once during the function prologue and can remain aligned to architecture specific requirements (e.g., Arm64’s 16 byte stack alignment requirement). However, it does mean that the BytecodeGenerator needs to calculate the maximum size of the stack frame during code generation.</p>
<p>由于寄存器文件特性，Ignition在表达式评估期间不能像full-codegen那样动态push和pop值到栈（唯一的例外是调用的参数， 然而这是在分离的内建函数完成，而不是在解释器中完成的）。这样的好处是栈能在函数开场时分配一次并且可以和特定的架构要求（例如，ARM64的16字节对齐的要求）保持一致。然而， 它意味着BytecodeGenerator需要在代码生成期间计算堆栈的最大尺寸。</p>
<p>Locals variables declared within the function are semantically hoisted to the top of the function by the parser. As such the number of locals is known ahead of time, and each local is assigned an index in the register file during the initial stage of AST walking. The number of extra registers required for inner contexts is also known ahead of time by the parser, and thus can be preallocated by the BytecodeGenerator during the initial stage of AST walking.</p>
<p>解析器将函数的局部变量在语意上提升到函数的顶部。因此，可以在开头知道局部变量的数量，并且在初始化遍历AST的步骤为每一个局部变量分配一个寄存器文件索引。解析器还提前知道内联上下文额外的寄存器数量，因此可以被BytecodeGenerator在初始化AST遍历期间阶段预分配。</p>
<p>Temporaries are required during expression evaluation, where there may be one or more live registers holding intermediate values in the expression tree until they are consumed. The BytecodeGenerator allocates registers using a scoped BytecodeRegisterAllocator. On each statement, a new scoped allocator is created for the statement, which is used by inner expression nodes to allocate temporary registers. These temporaries are only live for the lifetime of the expression statement, therefore when BytecodeGenerator finishes visiting this statement, the scoped allocator will go out of scope, and all temporary registers allocated by it will be released. The BytecodeGenerator keeps note of the maximum number of temporary registers which were allocated over the whole function’s code generation, and allocates enough extra slots in the register file for the largest number of temporaries required.</p>
<p>在表达式评估期间需要使用临时变量，其中可能是一个或多个活动的寄存器保存表达式树的中间值直到他们被消耗。BytecodeGenerator 使用一个限定范围的BytecodeRegisterAllocator分配寄存器。在每一个语句中为这个语句创建一个新的作用域分配器， 它被内联表达式节点用来分配临时的寄存器。这些临时变量仅在这个语句的生存期内有效， 因此当BytecodeGenerator完成对这个语句的访问后这个分配器将移除作用域，并且释放所有被它分配的临时寄存器。BytecodeGenerator记录整个函数代码生成中被分配的临时寄存器的最大数量， 并且在寄存器文件中为最大需求的临时变量数量分配足够的额外空间。</p>
<p>The layout of the register file will consist of the locals followed by the temporary registers, with no overlap between locals and temporary registers to keep access simple. Once the emitter has calculated the total size of the register file, it will use this to calculate the required frame size of the function, and will save this value in the BytecodeArray object.</p>
<p>寄存器文件的布局将由临时变量跟踪的局部变量决定，局部变量和临时变量之间美欧重叠以保持访问的简单。一旦发射器完成对寄存器文件大小的计算， 它将使用它去计算函数需要的帧大小， 并且将在BytecodeArray对象中保存这个值。</p>
<p>On entry to the function, the interpreter prologue will increment the stack pointer amount required to allocate space for the register file on the stack frame. All entries in the register file will initially be tagged pointers to undefined_value (like the locals pushed by full-codegen’s prologue). The interpreter will only every store tagged pointers in the entries of the register file, so the GC can walk over any register files on the stack visiting all entries as tagged pointers.</p>
<p>在进入这个函数时，解释器开场将为栈上的寄存器文件增加栈指针数量需求到分配的空间。所有的寄存器文件将初始化为指向undefined_value的指针（像被full-codegen push到局部变量）。解释器将仅仅将标记的指针储存在寄存器文件的入口，因此GC能遍历栈上的寄存器文件访问所有的标记指针的条目。</p>
<h2 id="Context-chains-上下文链"><a href="#Context-chains-上下文链" class="headerlink" title="Context chains 上下文链"></a>Context chains 上下文链</h2><p>The interpreter tracks the current context object in the context stack slot (which is part of the function’s fixed frame, and is accessed by bytecodes via Register::current_context()). When a new context is allocated, the BytecodeGenerator allocates a ContextScope object to track nested context chains. This allows the BytecodeGenerator to <em>unroll</em> nested context chain operations, enabling the interpreter to directly access any variables allocated within an inner context extension without having to walk the context chain.</p>
<p>解释器追踪堆栈（它是函数固定帧的一部分， 可以通过Register::current_context()访问字节码）中的上下文对象。当分配一个新的上下文时，BytecodeGenerator分配一个ContextScope对象去跟踪嵌套的上下文链。它允许BytecodeGenerator解开嵌套的上下文链操作，从而使解释器可以直接访问内部上下文扩展分配的任何变量，而不是遍历上下文链。</p>
<p>When a ContextScope object is allocated, a ContextPush bytecode is emitted. This bytecode moves the current context object into a register allocated by the BytecodeGenerator, and pushes the new context into the current context register. When an operation is performed on a variable which was allocated to a local context, the BytecodeGenerator finds the associated ContextScope’s, and checks which register the context object is currently allocated in, and can then directly load the variable out of the correct context slot in the context in pointed to by this register, rather than having to walk up the context chain to find the correct context. When the ContextScope goes out of scope, a ContextPop bytecode is emitted, which restores the parent context into the current context register.</p>
<p>当一个ContextScope对象被分配时，一个ContextPush字节码被发送。这个字节码移动当前的上下文对象到一个被BytecodeGenerator分配的寄存器， 并且push一个新的上下文到当前的上下文寄存器。当一个操作是查看一个变量时，它被分配一个局部的上下文， BytecodeGenerator找到关联的ContextScope， 并检查哪个是当前分配的上下文寄存器，然后直接通过这个寄存器从正确分配的上下文对象中加载这个变量， 而不是遍历上下文链来找到正确的上下文。当ContextScope超出作用域范围时，一个ContextPop字节码被发出， 它恢复父级上下文到当前的上下文寄存器。</p>
<p>By maintaining the current context as an explicit register, rather than only relying on the BytecodeGenerator to keep track of which register holds the current context, enables the interpreter to perform operations which require the current context (e.g., passing the context to JS function calls or runtime builtin operations) without having to take an extra operand to specify which register holds the current context.</p>
<p>通过维护当前的上下文当作一个明确的寄存器，而不是仅仅依赖BytecodeGenerator去跟踪哪个寄存器持有当前的上下文对象，使得解释器能在需要当前上下文时执行操作（例如，传递上下文到JS函数调用或者运行内建操作）， 而不必获取额外的操作来指定哪个寄存器持有当前的上下文。</p>
<h2 id="Constant-Pool-Entries-常量池记录"><a href="#Constant-Pool-Entries-常量池记录" class="headerlink" title="Constant Pool Entries 常量池记录"></a>Constant Pool Entries 常量池记录</h2><p>Constant pools are used to store heap objects and small integers that are referenced as constants in generated bytecode. Each BytecodeArray may have its own constant pool embedded in the BytecodeArray object. The constant pool is a FixedArray of pointers to heap objects. Bytecodes refer to constants in the constant pool by the index of each constant in the FixedArray. The indices are emitted as immediate unsigned operand values for bytecodes that take constant pool entries as inputs.</p>
<p>常量池用来存储堆对象和小整数，它能在生成的字节码中被引用为常量。每一个BytecodeArray有它自己的常量池嵌入在BytecodeArray对象中。常量池是一个指向堆对象的FixedArray指针。字节码通过在FixedArray中的每一个常量的索引来引用到常量池中的额索引。对于字节码获取常量池条目作为输入的操作，索引将以一个立即无符号数被发出。</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Ignition_(2).png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Ignition_(2).png"></p>
<p>Strings and heap numbers are always placed into the constant pool as they live in the heap and are referenced by pointers. Small integers and the strong referenced oddball type’s have bytecodes to load them directly and do not go into the constant pool. The constant pool can also store forward jump offsets and this is discussed below.</p>
<p>字符串和堆数字一直存储在常量池中，并且被指针引用。 小整数和强引用奇数类型字节码能直接加载它们，而不会进入常量池。常量池也能柏村前向跳转偏移， 下面将讨论它。</p>
<p>The constant pool is built during bytecode generation and there is a ConstantArrayBuilder class that is responsible for this. When bytecode needs to reference a constant, for instance loading a string, it passes the object to the constant array builder and asks for a constant pool index for the object. The ConstantArrayBuilder checks if the object is already present in the array and returns the existing index if so, otherwise it adds the object to the end of the constant pool being built and returns the index for the object. At the end of bytecode generation, the ConstantArrayBuilder emits a fixed array with the necessary object pointers.</p>
<p>常量池在字节码生成期间被创建，有一个ConstantArrayBuilder类来表示它。当字节码需要引用一个常量时，比如示例加载一个字符串， 它传递这个对象给常量池构建器并询问这个对象的一个常量池引用。ConstantArrayBuilder检查如果这个对象已经存在于数组中， 如果存在则返回已存在的引用， 否则它把这个对象增加到正在构建的常量池的末尾，然后染灰这个对象的索引。在字节码生成后，ConstantArrayBuilder发送一个带有必要对象指针的固定数组。</p>
<p>The logic described so far is relatively simple. Complexity comes from the use of the constant pool to store forward jump offsets. The issue with forward jumps is that the jump displacement is not known at the time the jump bytecode is emitted so a space is reserved for an jump displacement offset in the bytecode stream. The BytecodeArrayBuilder keeps track of this location and patches the jump when the displacement is known.</p>
<p>目前为止，逻辑描述相对简单。复杂性来自于常量池保存转发跳转便宜的使用。这个前向跳转的问题是， 在跳转代码被发送的时候不知道跳转的位置，因此在字节码流中预留一个跳转位置便宜的空间。BytecodeArrayBuilder保持追踪这个位置然后当知道跳转位置的时候补上。</p>
<p>In a simplified scenario, the bytecode generator emits a forward jump with an immediate byte operand left blank in the stream. When the displacement is known, the jump is patched. If the displacements fits within a byte operand then the displacement can be written directly into the blank operand. If the displacement is larger than a byte, then the displacement is put into the constant pool and both the jump bytecode and the operand are updated. The jump bytecode is updated to be a jump with a constant pool operand and the operand is updated to be the constant pool entry.</p>
<p>在简化的情况下，字节码生成器发送一个的前向跳转，但在流中将立即操作数字节留空。当位置知道后， 这个空白被补上。如果位置适合一个字节的操作数就直接写入位置，如果位置超过一个字节， 就把位置放入常量池中然后更新跳转字节码和操作数。跳转字节码被更新为跳转一个常量池操作数，然后这个操作数被更新到常量池的条目中。</p>
<p>In practice, the constant pool grows as code is generated and there are no restrictions on how large it can be. When emitting code, the BytecodeArrayBuilder needs to know what flavor of jump bytecode bytecode to emit for forward jumps: a jump taking a byte operand, or two byte operand, or four byte operand. Therefor the ConstantArrayBuilder class supports reserving constant pool entries. The reservation guarantees an index of a particular size will be available in future even though the value for the index is not currently known. The BytecodeArrayBuilder creates a reservation when it emits a forward jump and emits the bytecode having an operand size that matches the reservation made in the ConstantArrayBuilder. When the jump is patched, the reservation is cancelled if the displacement fits inside an immediate operand of the same size as the reservation. Otherwise, the constant pool reservation is committed to be the jump displacement value and the jump bytecode and operand patched to use the jump displacement value in the constant pool.</p>
<p>在实践中，常量池随着代码生成而增长，并且对大小没有严格限制。当代码发送时， BytecodeArrayBuilder需要知道发送什么类型的跳转字节码： 一个跳转指令获取一个字节的操作数，或者两个字节的操作数或者4个字节的操作数。 因此ConstantArrayBuilder类支持预留常量池条目。这个预留位保证了具体大小的引用在未来是可用的， 即使改索引的当前值是未知的。当BytecodeArrayBuilder发送一个前向跳转指令时创建一个预留位，并且发送一个操作数大小的字节码， 这个字节码匹配ConstantArrayBuilder中的预留位模式。当跳转被补齐时，如果位置适合相同大小的立即操作数，预留位被取消， 否则常量池预留位被提交到跳转位置，并且跳转字节码和操作数被更新到使用跳转到常量池中的位置。</p>
<h2 id="Local-Control-Flow-局部控制流"><a href="#Local-Control-Flow-局部控制流" class="headerlink" title="Local Control Flow 局部控制流"></a>Local Control Flow 局部控制流</h2><p>Javascript has the usual set of imperative control flow primitives at the language level such as if statements, if..else statements, for loops, while loops, do loops, and switch statements. It also has the the language specific construct for..in for iterating over object properties and also breakable named blocks. These control flow constructs only affect execution within a function compiled to bytecode.</p>
<p>Javascript通常有语言级别的原始命令试控制流， 如if语句， if…else语句，for循环， while循环，do 循环和switch语句。它也有一这个语言特别的结构 for…in用来迭代对象的属性以及打破命名块。这些控制流结构仅仅影响函数编译到字节码的执行。</p>
<p>The BytecodeGenerator converts the AST forms of Javascript’s flow control statements into control flow builder class instances that generate the corresponding bytecode. Control flow at the bytecode level is implemented as a set of bytecodes for conditionally and unconditionally jumping. Supporting Javascript’s for..in requires additional bytecodes to get the information to be iterated over and advancing to elements in the collection.</p>
<p>BytecodeGenerator从Javascript的流控制语句形式的AST转换为生成相应的字节码的控制流构建类实例。字节码层级中的控制流实现为一个有条件和无条件跳转的集合。支持for..in需要附加的字节码，用来获取被迭代对象的信息并可以前进到集合中的元素。</p>
<p>To facilitate building control flow structures, the BytecodeArrayBuilder supports the notion of labels that allow offsets to be specified. When the position of a label is known, the BytecodeGenerator binds the label to the current position with the BytecodeArrayBuilder::Bind() call. The BytecodeGenerator can refer to a label before it is bound when generating code for forward jumps. The BytecodeArrayBuilder checks that all labels referenced in bytecode are bound before the BytecodeArray is emitted. Because the Bind() call binds a label to the end of the bytecode being generated, labels are always constrained to target offsets within the bytecode array. The target offset for an emitted jump is present as either an immediate operand value in the bytecode or in the constant pool. There is no support for jumping to a dynamically computed value, for instance jumping to an offset in a register.</p>
<p>为了促进控制流结构的构建，BytecodeArrayBuilder支持允许指定偏移量的标签概念。当一个标签的位置已知时， BytecodeGenerator通过调用BytecodeArrayBuilder::Bind()绑定这个标签到当前的位置。当生成跳转代码时，BytecodeGenerator能在他被绑定之前引用到一个标签。BytecodeArrayBuilder在BytecodeArray被发送之前检查字节码中所有的标签引用是否被绑定。因为Bind函数调用绑定一个标签到要生成的字节码数组的末尾，标签一直被限制在字节码数组的目标偏移量上。被发送的跳转的目标偏移代表一个立即操作数或常量池中的值。它们不支持跳转到动态计算的值， 例如实例跳转到寄存器中的偏移。</p>
<p>An example generating control flow is shown below for an if..else statement.</p>
<p>下面是一个if…else语句生成的控制流</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%202.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%202.png"></p>
<p>If..else is the simplest control flow structure emitted by the generator. For the more complex control flow structures like loops and breakable blocks, the BytecodeGenerator employs control flow builders and control scopes.</p>
<p>if…else是被生成器发出的最简单的控制流结构。对于更复杂的控制流结构像循环和中断块，BytecodeGenerator 采用控制流构建器和控制作用域。</p>
<p>All loops use instances of the same control flow builder, the LoopBuilder. The LoopBuilder has a set of labels for the loop condition, the loop header, the target of continue/next, and the end of the loop. The visitor for the loop statement establishes the label positions of the loop header, loop condition, and the of end loop. It also visits the statements in the iteration body by calling BytecodeGenerator::VisitIterationBody. This visitor body instantiates a ControlScopeForIteration and pushes this onto a stack in the BytecodeGenerator and then visits the statements in the loop body. If a break statement or continue statement is hit, the visitor for these statements peeks at the current ControlScopeForIteration and signals a break (or continue). The control scope then invokes the appropriate method on its associated LoopBuilder which emits the appropropriate jumps to its labels.</p>
<p>所有的循环使用相同的控制流构建器实例LoopBuilder。LoopBuilder有一组用户循环条件，循环头，继续/下一步， 结束的标签集合。循环语句的访问建立循环头，循环田间和结束循环的标签位置。它通过调用BytecodeGenerator::VisitIterationBody访问迭代器主体的语句。改访问器主体实例化ControlScopeForIteration并且push它到BytecodeGenerator的堆栈中，然后访问循环体的语句。如果遇到一个break或continue语句， 这些语句的访问器将窥探当前的ControlScopeForIteration并且发出一个break（或continue）信号。然后控制作用域在其关联的LoopBuilder上调用合适的方法， 这个方法给标签发送合适的跳转跳转。</p>
<p>The ControlFlowBuilder classes ensure the emitted bytecode has the same control flow order as the source code. This natural ordering means the only time backwards branches are emitted in bytecode is in loop statements returning to the head of the loop. The ordering means no additional loop analysis need be performed when converting from bytecode form into TurboFan compiler graph form. The branch analysis for graph building need only identify the sites of jumps and their targets.</p>
<p>ControlFlowBuilder类确保发送的字节码和源码有相同的控制流顺序。它的自然顺序意味着唯一向后的分支是发送返回到循环的开头的循环语句字节码。这个顺序意味着当字节码进入TurboFan编译器图时没有附加的循环分析需要被转换。这个分支对构建图的分析仅仅需要标识跳转的位置及目标。</p>
<h2 id="Exception-Handling-异常处理"><a href="#Exception-Handling-异常处理" class="headerlink" title="Exception Handling 异常处理"></a>Exception Handling 异常处理</h2><p>TODO</p>
<h1 id="Interpreter-Code-Execution-解释器执行代码"><a href="#Interpreter-Code-Execution-解释器执行代码" class="headerlink" title="Interpreter Code Execution 解释器执行代码"></a>Interpreter Code Execution 解释器执行代码</h1><p>The Ignition interpreter is a register-based, indirect threaded interpreter. The entry point to the interpreter from other JavaScript code is the InterpreterEntryTrampoline builtin stub. This builtin sets up an appropriate stack frame, and loads reserved machine registers (e.g., the bytecode pointer, interpreter dispatch table pointer) with the appropriate values before dispatching to the first bytecode of the called function.</p>
<p>Ignition解释器是基于寄存器的，间接的线程解释器。其他JavaScript代码到解释器的入口点是内建的InterpreterEntryTrampoline。这个内建的stub设置了合适的堆栈， 在分派第一个调用函数的字节码之前加载预留的带有合适值的寄存器（如：字节码指针，解释器分派表指针）。</p>
<h2 id="Stack-frame-layout-and-reserved-machine-registers-堆栈布局和预留机器寄存器"><a href="#Stack-frame-layout-and-reserved-machine-registers-堆栈布局和预留机器寄存器" class="headerlink" title="Stack frame layout and reserved machine registers 堆栈布局和预留机器寄存器"></a>Stack frame layout and reserved machine registers 堆栈布局和预留机器寄存器</h2><p>An example of the layout of a stack frame for the interpreter is shown below:</p>
<p>下面是一个解释器堆栈的布局的示例</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%203.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%203.png"></p>
<p>The interpreter stack frame is built by the InterpreterEntryTrampoline builtin stub, which pushes the fixed frame values (Caller PC, Frame Pointer, JSFunction, Context, Bytecode Array and Bytecode Offset) and then allocates space in the stack frame for the register file (the BytecodeArray object contains an entry which tells the builtin how large a stack frame the function requires). It then writes undefined to all the registers in this register file, which ensures the GC doesn’t see any invalid (i.e., non-tagged) pointers when it walks the stack.</p>
<p>解释器栈帧被内建的InterpreterEntryTrampoline创建， 它push固定的帧值(Caller PC, Frame Pointer, JSFunction, Context, Bytecode Array 和 Bytecode Offset)然后为寄存器文件在栈上分配空间（BytecodeArray包含一个入口，它告诉这个函数需要多大的内建帧空间）。然后它将寄存器文件的所有值写成undefined， 确保GC在遍历堆栈时不会看到任何不可用的指针。</p>
<p>The InterpreterEntryTrampoline builtin stub initializes some fixed machine registers which are used by the interpreter, namely:</p>
<p>InterpreterEntryTrampoline内建stub初始化一些固定的被解释器使用的机器寄存器，并命名：</p>
<ul>
<li><p>kInterpreterAccumulatorRegister: stores the implicit accumulator interpreter register</p>
<p>  kInterpreterAccumulatorRegister  存储隐式的累加寄存器</p>
</li>
<li><p>kInterpreterBytecodeArrayRegister: points the the start of the BytecodeArray object which is being interpreted.</p>
<p>  kInterpreterBytecodeArrayRegister： 指向解释器要开始的BytecodeArray对象</p>
</li>
<li><p>kInterpreterBytecodeOffsetRegister: the current offset of execution in the BytecodeArray (in essense the bytecode PC).</p>
<p>  kInterpreterBytecodeOffsetRegister：在BytecodeArray中执行当前偏移(本质是PC字节码)</p>
</li>
<li><p>kInterpreterDispatchTableRegister: points to the interpreter’s dispatch table, used to dispatch to the next bytecode handler.</p>
<p>  kInterpreterDispatchTableRegister: 指向解释器分派表的指针，被用来分派下一个字节码处理器</p>
</li>
<li><p>kInterpreterRegisterFileRegister: points to the start of the register file (will soon be removed now that TurboFan can use the parent frame pointer directly).</p>
<p>  kInterpreterRegisterFileRegister: 指向寄存器文件开始的指针（将很快被删除，因为现在TurboFan能直接使用父帧指针）</p>
</li>
<li><p>kContextRegister: points to the current context object (will soon be removed and all access will be via interpreter register Register::current_context()</p>
<p>  kContextRegister： 指向当前上下文对象的指针（将很快被删除， 所有的访问将痛殴解释器寄存器的Register::current_context()）</p>
</li>
</ul>
<p>It then <em>calls</em> the bytecode handler for the first bytecode in the bytecode array stream. The registers initialized above are available to the bytecode handlers as TurboFan parameter nodes, due to the fact that the calling convention for bytecode dispatch specifies associated parameters for each of the fixed machine registers.</p>
<p>它然后对字节码流中的第一个字节码调用字节码处理器。上面初始化的寄存器可以作为TurboFan的参数节点提供给字节码处理器， 因为实际上调用对字节码分派指定的关联参数约定了每一个固定的及其寄存器。</p>
<p>If the bytecode handler is simple and doesn’t call any other function (other than the tail call in the dispatch operation) then TurboFan can elide stack frame creation for this bytecode handler. However, in more complex bytecode handlers, TurboFan will build a new STUB frame when execution enters the bytecode handler. Other than the required fixed frame, this frame only stores machine register values spilled by TurboFan (e.g., callee saved registers across a call). All the state associated with the interpreted function lives in the parent interpreted frame.</p>
<p>如果字节码处理器是简单的，不调用任何函数（除了分派操作中的尾调用），TurboFan可以消除为这个字节码处理器创建的堆栈。然而，在更多的字节码处理器中，当执行进入字节码中时，TurboFan将构建一个新的STUB帧。除了需要的固定帧，这个帧仅保存由TurboFan溢出的机器寄存器的值（例如：调用过程中调用者保存的寄存器）。所有的状态关联到存在于父帧中的解释器函数。</p>
<h2 id="Interpreter-Register-Access-访问解释器寄存器"><a href="#Interpreter-Register-Access-访问解释器寄存器" class="headerlink" title="Interpreter Register Access 访问解释器寄存器"></a>Interpreter Register Access 访问解释器寄存器</h2><p>As described <a href="about:blank#interpreter-register-allocation">above</a>, all local variables and temporaries will be allocated to specific registers within the function’s <em>register file,</em> on its stack frame, during bytecode generation. These variables, as well as the function’s arguments, can be accessed by bytecode handlers as interpreter registers. The register on which a bytecode handler should operate is specified as a bytecode operand in the bytecode stream. The interpreter loads the operand from the bytecode stream to get the register index on which it should operate. This index is a word-based offset from the start of the register file, which can be either positive (to access which live above the register file on the stack, such as function arguments) or negative (to access locals allocated by the function itself on its register file). The interpreter accesses a given register by scaling the operand’s index to be a byte offset, and then loading from or store to the memory location at kInterpreterRegisterFileRegister + offset.</p>
<p>如上所述，在字节码生成期间，堆栈中所有的局部变量和临时变量将被分配到函数寄存器文件中指定的寄存器。这些变量以及函数的参数可以通过字节码处理器当作解释器寄存器访问。字节码处理器应该操作的字节码被指定为流中字节码的操作数。解释器从字节码流中获取它应该操作的寄存器索引。这个索引是一个从寄存器文件起始位置开始的基于双字节的偏移量，它可以是正数（去访问位于寄存器文件上方的堆栈， 例如函数参数）或者负数（去访问函数自身在寄存器文件中分配的局部变量）。解释器通过扫描操作数的索引到字节的偏移来访问一个给定的寄存器， 然后从kInterpreterRegisterFileRegister+offset的内存位置加载 或保存到这个内存的位置。</p>
<h2 id="Wide-operands-宽字符操作"><a href="#Wide-operands-宽字符操作" class="headerlink" title="Wide operands 宽字符操作"></a>Wide operands 宽字符操作</h2><p>Minimizing the size of generated bytecode is a major motivator for Ignition so the bytecode format is able to support operands of different widths. Ignition uses prefix special bytecodes to support wider operands. Ignition supports fixed width operand types and scalable width operands. The scalable width operands increase in size proportional to the prefix bytecode.</p>
<p>为Ignition生成字节码最小尺寸是主要动机， 因此字节码格式是表格来支持操作不同宽度的操作数。Ignition使用特别的字节码前缀来支持宽操作数。Ignition支持固定宽度的类型和可伸缩宽度的操作数。可伸缩宽度的操作数和前缀字节码的尺寸成比例增加。</p>
<p>The fixed width operands are for runtime call identifiers (16-bits) and flag operands (8-bits). Register operands, immediate value operands, index value operands, and register count operands all have a base size of 8-bits and are scalable up to 32-bits wide.</p>
<p>定宽操作数用于运行时调用标识符（16位）和标志操作数（8位）。寄存器操作数， 立即操作数， 索引操作数和寄存器计数操作数是8位的基本尺寸，并且可扩展为32位。</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%204.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%204.png"></p>
<pre><code>                   The effects of prefix bytecodes on the load accumulator bytecode

                          加载累加器时前缀字节码的影响</code></pre>
<p>The Wide prefix bytecode doubles the width of scalable operands making them 16-bits wide, and the ExtraWide prefix quadruples the width to 32-bits.</p>
<p>Wide前缀字节码可以使操作数扩展两杯到16位， ExtraWide前缀字节码将扩展到4被到32位。</p>
<p>To support dispatching prefixed, the bytecode dispatch table has entries for the scalable operands offset by 256 for each scaling so indices between 0-255 correspond to unscaled bytecodes, 256-511 correspond to bytecodes with the Wide prefix, and 512-767 correspond to bytecodes with the ExtraWide prefix.</p>
<p>为了支持带前缀的分派，字节码分派表具有可伸缩操作数偏移的条目, 每次缩放偏移256位， 因此0-255之间的索引符合未缩放的字节码，255-511代表Wide前缀的字节码， 512-767代表带有ExtraWide前缀的字节码。</p>
<p>Earlier Ignition designs, placed wide bytecodes into the same 8-bit space limiting the number of free bytecodes that could be used for other purposes such as bytecode specialization. The designs also had an elaborated register translation scheme for accessing wide register operands as it was not feasible to have scaled versions of all bytecodes. Using prefix bytecodes is cleaner and the overhead of 1-byte prefix is only incurred when used and the size overhead was less than 1% on the Octane-2.1 benchmark.</p>
<p>早期的Ignition设计将宽字符放在相同的8位字节码中，它限制了被用于其他目的的空闲字节码的数量， 例如专用的字节码。这个设计还具有用于访问wide寄存器操作的详细寄存器转换方案，因为获取所有字节码的可缩放版本是不可行的。使用前缀字节码更清晰，并且当使用时仅仅有一个字节的开销， 在Octane-2.1 的基准测试中消耗小于1%。</p>
<h2 id="JS-Calls-JS调用"><a href="#JS-Calls-JS调用" class="headerlink" title="JS Calls JS调用"></a>JS Calls JS调用</h2><p>Calls to other JS functions are handled by the Call bytecode. The BytecodeGenerator ensures that the arguments which will be passed to the call are in a contiguous set of registers. It then emits Call bytecode with a register operand specifying the register which holds the callee, a second register operand specifying the register which holds the start of the arguments to be passed to the call, and a third operand which specifies the number of arguments to pass.</p>
<p>调用其他JS函数被调用的字节码处理。BytecodeGenerator确保被传递给这次调用的参数在连续的寄存器中。然后发送带有寄存器指定调用操作数的字节码， 第一个参数是调用者，第二个寄存器操作数是指定被传递给调用函数参数起始位置的寄存器，第三个操作数是指定的参数的数量。</p>
<p>The interpreter Call bytecode handler updates the <em>bytecode offset</em> stack slot in the interpreted frame with the current bytecode offset. This allows stack walking code to calculate the bytecode pc for frames on the stack. It then calls the InterpreterPushArgsAndCall builtin, passing the callee, the memory location of the first argument register, and the number of arguments. The InterpreterPushArgsAndCall builtin then copies the argument values from the range <first_arg_register>…&lt;first_arg_register + count&gt; and pushes these values to the end of the stack. It then invokes the Call builtin, which is the same builtin used by full-codegen to evaluate the target address to call for the given callee. Calls to other interpreted functions are treated the same as calls to JITed functions - the Call builtin will load the JSFunction’s code entry field, which will point to the InterpreterEntryTrampoline builtin stub for interpreted functions, and thus the call will invoke the InterpreterEntryTrampoline and reenter the interpreter.</p>
<p>解释器调用字节码处理器用当前的字节码偏移更新在解释器帧上字节码偏移位置。 这允许栈遍历堆栈代码为栈帧上的字节码计算字节码PC。然后调用内建的InterpreterPushArgsAndCall，传递被调用者，第一个参数寄存器的内存位置和参数的数量。内建的InterpreterPushArgsAndCall然后从<first_arg_register>…&lt;first_arg_register + count&gt;复制参数值，并push他们到堆栈的末尾。然后调用内建的Call函数，该函数于full-codegen一样用来为给出的被调用者评估调用的目标地址。调用其他的解释器函数和调用JIT的函数相同 - 内建Call将加载JSFunctio的代码入口字段， 它指向解释器函数的内建InterpreterEntryTrampoline STUB， 因此改调用将调用InterpreterEntryTrampoline并重新进入解释器。</p>
<p>When an interpreted function returns, the interpreter tail calls the InterpreterExitTrampoline builtin stub, which tears-down the stack frame and restore control to the calling function, returning the value held in the accumulator at the time of the return bytecode as the return value.</p>
<p>当解释器函数被返回，解释器尾调用内建的InterpreterExitTrampoline stub， 它将展开堆栈并恢复控制权到调用的函数， 返回累计器中保留的值。</p>
<h2 id="Property-loads-stores-属性加载-保存"><a href="#Property-loads-stores-属性加载-保存" class="headerlink" title="Property loads / stores 属性加载/保存"></a>Property loads / stores 属性加载/保存</h2><p>Bytecodes which load or store property on JS objects do so via inline caches (ICs). The bytecode handlers call the same LoadIC and StoreIC code stubs as are used by JITed code (e.g., full-codegen). Since the Load/StoreICs no longer patch code (instead operating directly on the TypeFeedbackVector) this means the same ICs can be used for both JITed code and Ignition.</p>
<p>字节码通过内联缓存（ICs）加载或保存JS对象的属性。字节码处理器和JIT代码（例如： full-codegen）一样调用相同的LoadIC和StoreIC代码。由于加载/保存不再补齐代码（直接在TypeFeedbackVector上操作），这意味着相同的ICs可以被JIT和Ignition同时使用。</p>
<p>The bytecode handler passes the function’s TypeFeedbackVector, to the appropriate IC stub along with the type feedback slot associated with the AST node of the operation. The IC stub can update entries in the TypeFeedbackVector in the same manner as it does now for the full-codegen compiler, enabling learning of type feedback for later use by the optimizing compiler.</p>
<p>字节码处理器传递函数的TypeFeedbackVector属性以及与操作AST节点相关联的类型反馈到合适的IC stub。IC stub现在可以和full-codegen编译器一样的方式更新TypeFeedbackVector中的条目，能从类型反馈中学习， 以提供后续的编译优化。</p>
<h2 id="Binary-ops"><a href="#Binary-ops" class="headerlink" title="Binary ops"></a>Binary ops</h2><p>For BinaryOps and other UnaryOps (e.g., ToBoolean) full-codegen currently employs ICs which patch machine code. We can’t use these ICs in Ignition since they would patch the bytecode handler code (which is not a function specific call site). As such, we currently don’t collect any type feedback for Binary or Unary operations.</p>
<p>对于BinaryOps和UnaryOps（例如：ToBoolean），full-codegen目前使用ICs补齐机器码。我们不能在Ignition中使用ICs，因为他们会修补字节码（它不是一个特别的函数调用）。因此我们目前不收集有段Binary和Unary操作的类型反馈。</p>
<p>At present, most Binary and Unary ops call runtime functions which perform the given operations. We are in the process of replacing these calls with calls to stubs written using the CodeStubAssembler which perform the common cases inline, only calling out to the runtime for more complex situations. Currently we call these stubs, however since they are written using the CodeStubAssembler, we will be able to inline the code directly into the interpreter’s bytecode handlers easily.</p>
<p>目前，大部分Binary和Unary操作调用给定的运行时函数。我们正在将这些调用替换为用CodeStubAssembler编写的stub调用，这些调用以内联的方式展示通用的情况，仅在复杂的清康下调用运行时函数。目前我们调用这些stub, 然而由于他们使用CodeStubAssembler编写， 我们将能更容易地直接将代码内联到解释器的字节码处理器。</p>
<p>As a future optimization, we may employ back-patching of the actual bytecodes to point to specialized bytecode handlers for a given operation (e.g., inlining SmiAdd as a specific bytecode), however this is dependent upon the decision we end up making regarding collection of type feedback for BinaryOps and UnaryOps in Ignition.</p>
<p>在未来的优化中， 我们能使用实际字节码的反向修补来指向给定操作的特别字节码处理器（例如：内联SmiAdd作为一个特别的字节码）， 然而它由我们在Ignition中对BinaryOps和UnaryOps收集的类型决定。</p>
<h1 id="TurboFan-Bytecode-Graph-Builder-TurboFan字节码图构建器"><a href="#TurboFan-Bytecode-Graph-Builder-TurboFan字节码图构建器" class="headerlink" title="TurboFan Bytecode Graph Builder TurboFan字节码图构建器"></a>TurboFan Bytecode Graph Builder TurboFan字节码图构建器</h1><p>The BytecodeArray built by the BytecodeGenerator contains all the information necessary to be fed into Turbofan and built a TurboFan compilation graph. This is implemented by the BytecodeGraphBuilder.</p>
<p>BytecodeArray通过BytecodeGenerator构建， 包含所有需要喂给TurboFan和TurboFan构建图的必要信息。它是BytecodeGraphBuilder实现的。</p>
<p>The BytecodeGraphBuilder starts by walking the bytecode to perform some basic branch analysis, which finds backward and forward branch target bytecodes. This is used to set up the appropriate loop header environments in the BytecodeGraphBuilder while building the TurboFan graph.</p>
<p>BytecodeGraphBuilder首先遍历字节码去执行一些基本的分支分析，这个分析将查找前向和后向分支的目标代码。当构建TurboFan图时这被用来在BytecodeGraphBuilder中设置合适的循环头环境。</p>
<p>BytecodeGraphBuilder then walks the BytecodeArray again, visiting every bytecode and calling a bytecode specific visitor for each. The bytecode visitor functions read the bytecode operands from the BytecodeArray, and then add operations to the TurboFan graph to perform the operation of that bytecode. Many bytecodes have a direct mapping to an existing JSOperator in TurboFan.</p>
<p>BytecodeGraphBuilder然后再次遍历BytecodeArray， 访问每一个字节码，然后调用一个字节码指定的每一个访问器。字节码访问器函数从BytecodeArray读取字节码操作， 然后加到TurboFan图中以执行这个字节码的操作。许多字节码能直接映射到TurboFan中已经存在的JSOperator上。</p>
<p>The BytecodeGraphBuilder maintains an environment which tracks which nodes represent to value stored in each of the registers in the BytecodeArray’s register file (including the accumulator register). The environment also tracks the current context object (which is updated due to Push/PopContext bytecodes). When the visitors visit a bytecode which reads a value from register, it looks up the node in the environment associated with that register, and uses this as the input node to the JSOperator node being built for the current bytecode. Similarly, for operations which output a value to a register or the accumulator, the visitor will update the register in the environment with the new node when it is complete.</p>
<p>BytecodeGraphBuilder维护一个环境，这个环境追踪哪些节点代表的值存储在BytecodeArray的寄存器文件的寄存器中（包括累加寄存器）。这个环境也追踪当前的上下文对象（它被Push/PopContext字节码更新）。当访问器访问一个字节码是，它从寄存器读取一个值， 查看这个节点在环境中关联的那个寄存器， 然后使用这个寄存器作为输入节点输入给JSOperator节点开始构建当前的字节码。 相似的， 对于输出一个值到寄存器或累计器的操作， 当它完成时访问器将使用新的节点更新环境中的寄存器。</p>
<h2 id="Deoptimization-去优化"><a href="#Deoptimization-去优化" class="headerlink" title="Deoptimization 去优化"></a>Deoptimization 去优化</h2><p>Javascript operations can trigger deoptimizations from optimized code back to the unoptimized bytecode during execution. In order to support deoptimization, the BytecodeGraphBuilder needs to keep track of the state of the interpreter’s stack frame so that it can rebuild the interpreter stack frame on deoptimization and re-enter the function at the deoptimization point.</p>
<p>Javascript操作能在执行期间触发去优化，从优化的代码块返回到未优化的的字节码。为了支持去优化操作， BytecodeGraphBuilder需要保持跟踪解释器堆栈的状态，因此它能在去优化时重新构建解释器的堆栈，然后在去优化的点重新进入函数。</p>
<p>The environment already tracks this, by keeping track of the nodes associated with each register at each point of the bytecode execution. The BytecodeGraphBuilder checkpoints this information in a FrameState node for JSOperator nodes which could trigger a deoptimization (either eager - with the checkpoint based on the state before the node executes, or lazy - with the checkpoint after the node has executed).</p>
<p>环境也跟踪this，依靠在执行中的每个点对每个寄存器相关联的节点保持跟踪。BytecodeGraphBuilder在一个JSOperator的FrameState节点检查this信息，这个节点触发去优化操作（或者期望 - 在这个节点执行之前基于状态检查，或赖执行 -在这个节点已经被执行之后）。</p>
<p>Since each bytecode maps to a single JSOperator node, this means that we will only ever deoptimize to a point immediately before or immediately after a bytecode. As such, we use the bytecode offset as the BailoutId in the deoptimization points. When TurboFan generates code to deal with potential deoptimization, it serializes a TranslatedState record which describes how to rebuild an interpreted frame for this deoptimization point. This is based on FrameState node for this deoptimization point. When this deopt point is hit, the interpreted frame is built using this TranslatedState record, and the runtime re-enters into the interpreter at the appropriate bytecode offset using the InterpreterNotifyDeoptimized builtin.</p>
<p>由于每一个字节码映射一个单一的JSOperator节点，这意味着我们能仅仅一个字节码之前或之后去优化。因此，我们在去优化的点使用字节码偏移作为BailoutId。当TurboFan生成字节码去处理潜在的去优化操作， 它序列化一个TranslatedState记录，记录描述了如何为去优化的点重新构建一个解释器帧。这是基于去优化点的FrameState节点。当这个去优化的点触发时，解释器帧被使用TranslatedState记录重新构建， 然后运行时使用内建的InterpreterNotifyDeoptimized在合适的字节码偏移处重新进入解释器。</p>
<h1 id="Debugging-support-支持调试"><a href="#Debugging-support-支持调试" class="headerlink" title="Debugging support 支持调试"></a>Debugging support 支持调试</h1><p>To enable the debugger breakpoint code executed by the interpreter, the debugger copies the BytecodeArray object of the function, and then replace any bytecode which is the target of a breakpoint with a special DebugBreak bytecode. Since all bytecodes are at least one byte, no extra space needs to be allocated in the bytecode stream to ensure breakpoints can be set. There are variants of the DebugBreak bytecode for each size of bytecodes to ensure that the BytecodeArray can still be iterated correctly. There are also DebugBreakWide and DebugBreakExtraWide bytecodes, which as well as acting as breakpoints, also prefix the next bytecode as being a Wide or ExtraWide variant (in the same manner <a href="about:blank#wide-operands">as the Wide and ExtraWide bytecodes</a> on non-breakpoint code).</p>
<p>为了让解释器开启代码的调试断点，调试器将复制函数对象的 BytecodeArray对象， 然后用一个特殊的DebugBreak字节码替换断点位置的任何字节码。因为所有的字节码至少一个字节，所以无需在字节码流中分配额外的字节赖确保可以设置断点。每种尺寸的字节码都有DebugBreak字节码的变种用来确保BytecodeArray仍然能被正确的迭代。还有DebugBreakWide和DebugBreakExtraWide字节码，可以作为断点也可以作为下一个字节码的前缀Wide和ExtraWide的变体（与Wide和ExtraWide的非断点字节码相同）。</p>
<p>Once a breakpoint is hit, the interpreter calls into the debugger. The debugger can resume execution by looking at the function’s real BytecodeArray and dispatching to the actual bytecode which was replaced by the DebugBreak bytecode.</p>
<p>一旦一个断点被触发，解释器调用进入调试模式。调试模式能通过查找函数的真实BytecodeArray然后分派实际的字节码替换DebugBreak字节码而继续执行</p>
<p>More details are available in <a target="_blank" rel="noopener" href="https://docs.google.com/a/google.com/document/d/14P4GwauRJnomjQs9_p_b-naSCm_pjMbHtWT57VmDMJg/edit?usp=drive_web">Debugging support for Ignition</a> design doc.</p>
<p>更多详细的可用文档在 <a target="_blank" rel="noopener" href="https://docs.google.com/a/google.com/document/d/14P4GwauRJnomjQs9_p_b-naSCm_pjMbHtWT57VmDMJg/edit?usp=drive_web">Debugging support for Ignition</a></p>
<h2 id="Source-Positions-源码位置"><a href="#Source-Positions-源码位置" class="headerlink" title="Source Positions 源码位置"></a>Source Positions 源码位置</h2><p>Source positions are emitted alongside bytecode when bytecodes are emitted by the bytecode generator. There are two types of source position: statement positions and expression positions. Statement positions are used for stepping between statements in the debugger. A statement position occurs a location where the debugger can step to before the bytecode it is associated with is dispatched. Expression positions are used to provide stack trace information when exceptions are raised in expressions. When an exception is raised the debugger scans back from the site of the exception looking for an expression position and this is used in the stack trace.</p>
<p>源码位置被字节码生成器随字节码一起发送。有两种源码位置类型：语句位置和表达式位置。语句位置被调试器用来在步骤之间跳转。语句位置出现在调试器能分派与它关联的字节码之前的可移动的位置。表达式语句被用来当表达式异常时提供堆栈跟踪信息。当出现异常时，调试器从异常位置反向扫描寻找表达式位置并用于堆栈的追踪中。</p>
<p><img src="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%205.png" alt="Ignition%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%209de0caf5e9904a158c287daf18d68d80/Untitled%205.png"></p>
<pre><code>                                      Source positions in source code and bytecode.

                                                     源码和字节码中的源码位置</code></pre>
<p>The bytecode generation process needs to maintain source positions for the debugger and exception reporting to work correctly. Any optimizations in the bytecode generation process need to ensure source positions have the same causal ordering. Some expression positions can be elided because they are associated with bytecodes that can not produce an exception or are duplicates.</p>
<p>字节码生成过程需要为调试器和异常报告正确工作维护源码位置。在字节码生成过程的任何优化需要确保源码位置有相同的因果顺序。有些异常位置能被省略，因为他们与不会产生异常的或者是重复的字节码相关联。</p>
<h2 id="Profiler-Support-探查器支持"><a href="#Profiler-Support-探查器支持" class="headerlink" title="Profiler Support 探查器支持"></a>Profiler Support 探查器支持</h2><p>TODO</p>
<h1 id="Future-work-后续工作"><a href="#Future-work-后续工作" class="headerlink" title="Future work 后续工作"></a>Future work 后续工作</h1><p>TODO - describe possible specialized bytecode patching optimizations.</p>
<p>TODO - describe possible super-bytecodes.</p>
<p>TODO - describe type feedback for binary ops.</p>
<h1 id="Appendix-A-Table-of-Bytecodes"><a href="#Appendix-A-Table-of-Bytecodes" class="headerlink" title="Appendix A: Table of Bytecodes"></a>Appendix A: Table of Bytecodes</h1><p><a target="_blank" rel="noopener" href="https://www.notion.so/roadup/V8-99139263196b460b8a334b6a46ec7e45"></a></p>
<h1 id="Appendix-B-Reading-Material"><a href="#Appendix-B-Reading-Material" class="headerlink" title="Appendix B: Reading Material"></a>Appendix B: Reading Material</h1><p><em>Threaded Code</em>, in Wikipedia entry, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Threaded_code">https://en.wikipedia.org/wiki/Threaded_code</a></p>
<p><em>Revolutionizing Embedded Software</em>, Kasper Verdich Lund and Jakob Roland Andersen, in Master’s Thesis at University of Aarhus, <a target="_blank" rel="noopener" href="http://verdich.dk/kasper/RES.pdf">http://verdich.dk/kasper/RES.pdf</a>.</p>
<p><em>Inside JavaScriptCore’s Low-Level Interpreter</em>, Andy Wingo’s blog, <a target="_blank" rel="noopener" href="https://wingolog.org/archives/2012/06/27/inside-javascriptcores-low-level-interpreter">https://wingolog.org/archives/2012/06/27/inside-javascriptcores-low-level-interpreter</a></p>
<p><em>SquirrelFish</em>, David Manelin’s blog, <a target="_blank" rel="noopener" href="https://blog.mozilla.org/dmandelin/2008/06/03/squirrelfish/">https://blog.mozilla.org/dmandelin/2008/06/03/squirrelfish/</a></p>
<p><em>Context Threading</em>, Marc Berndl, Benjamin Vitale, Mathew Zaleski, and Angela Demke Brown, in CGO ’05: Proceedings of the international symposium on Code generation and optimization, <a target="_blank" rel="noopener" href="http://www.cs.toronto.edu/syslab/pubs/demkea_context.pdf">http://www.cs.toronto.edu/syslab/pubs/demkea_context.pdf</a> (also Mathew Zeleski’s thesis <a target="_blank" rel="noopener" href="http://www.cs.toronto.edu/~matz/dissertation/">http://www.cs.toronto.edu/~matz/dissertation/</a>)</p>
<p><em>Optimizing Indirect Branch Prediction Accuracy in Virtual Machine Interpreters</em>, M. Anton Ertl and David Gregg, in PLDI’03, <a target="_blank" rel="noopener" href="http://www.eecg.toronto.edu/~steffan/carg/readings/optimizing-indirect-branch-prediction.pdf">http://www.eecg.toronto.edu/~steffan/carg/readings/optimizing-indirect-branch-prediction.pdf</a></p>
<p><em>The Case for Virtual Register Machines</em>, Brian Davis, Andrew Beatty, Kevin Casey, David Gregg, and John Waldron, in Interpreters, Virtual Machines, and Emulators (IVME’03), <a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=858575">http://dl.acm.org/citation.cfm?id=858575</a></p>
<p><em>Virtual Machine Showdown: Stack vs Registers</em>, Yuhne Shi, David Gregg, Andrew Beatty, and M. Anton Ertl, in VEE’05. <a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf">https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf</a></p>
<p><em>vmgen - A Generator of Efficient Virtual Machine Interpreters</em>, M. Anton Ertl, David Gregg, Andreas Krall, and Bernd Paysan, in Software: Practice and Experience, 2002. <a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.7676&rep=rep1&type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.7676&amp;rep=rep1&amp;type=pdf</a></p>
<p><em>The Self Bibliography</em>, <a target="_blank" rel="noopener" href="https://www.cs.ucsb.edu/~urs/oocsb/self/papers/papers.html">https://www.cs.ucsb.edu/~urs/oocsb/self/papers/papers.html</a></p>
<p><em>Interpreter Implementation Choices</em>, <a target="_blank" rel="noopener" href="http://realityforge.org/code/virtual-machines/2011/05/19/interpreters.html">http://realityforge.org/code/virtual-machines/2011/05/19/interpreters.html</a></p>
<p><em>Optimizing an ANSI C Interpreter with Superoperators</em>, Todd A. Proebstring, in POPL’95, <a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=199526">http://dl.acm.org/citation.cfm?id=199526</a></p>
<p><em>Stack Caching for Interpreters</em>, M Anton Ertl, in SIGPLAN ’95 Conference on Programming Language Design and Implementation, <a target="_blank" rel="noopener" href="http://www.csc.uvic.ca/~csc485c/Papers/ertl94sc.pdf">http://www.csc.uvic.ca/~csc485c/Papers/ertl94sc.pdf</a></p>
<p><em>Code sharing among states for stack-caching interpreter</em>, Jinzhan Peng, Gansha Wu, Guei-Yuan Lueh, in Proceedings of the 2004 workshop on Interpreters, Virtual Machines, and Emulators, <a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=1059584">http://dl.acm.org/citation.cfm?id=1059584</a></p>
<p><em>Towards Superinstructions for Java Interpeters</em>, K. Casey, D. Gregg, M. A. Ertl, and A. Nisbet, in</p>
<p>Proceedings of the 7th International Workshop on Software and Compilers for Embedded Systems, <a target="_blank" rel="noopener" href="http://rd.springer.com/chapter/10.1007/978-3-540-39920-9_23">http://rd.springer.com/chapter/10.1007/978-3-540-39920-9_23</a></p>
<p><em>Branch Prediction and the Perfomance of Interpreters - Don’t Trust Folklore</em>, Erven Rohou, Bharath Narasimha Swamy, Andre Seznec. International Symposium on Code Generation and Optimization, Feb 2015, Burlingame, United States. <a target="_blank" rel="noopener" href="https://hal.inria.fr/hal-00911146/document">https://hal.inria.fr/hal-00911146/document</a></p>

      </div>
      
      
      
    </div>
    

    
    
    


      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
